# 一次项目打包优化

随着项目不断变大文件越来越多，打包的速度越来越慢，最终忍无可忍开始着手对项目的打包进行优化。顺便将这次的优化过程记录下来供以后参考。

## 1. 分析打包变慢的原因

对于项目打包时间的优化，首先就是分析打包变慢的原因，找到了原因才能有针对的进行优化。webpack打包速度变慢的主要原因是webpack要将不同的依赖文件交由不同loader进行处理，随着项目文件不断增加，整个项目所需的loader时间就越长，打包速度就自然而然的变慢许多。**因此优化打包速度的关键就是优化loader处理文件的时间。**

## 2. 量化loader的处理文件的时间

为了优化loader处理文件的时间，我首先需要分析是哪部分loader处理时间过长从而进行针对性的优化。这里我采用了**speed-measure-webpack-plugin**这个webpack插件对各个loader的打包时间进行分析。代码如图所示

![speed-measure-webpack-plugin使用方法](/Users/chengliang/Projects/Frontend/2020-08-07/img/img-1.jpg)

speed-measure-webpack-plugin插件的使用方式十分简单，我们只需要新建插件实例然后将我们的webpack配置对象传入插件实例的wrap方法即可。

配置好speed-measure-webpack-plugin插件后只需要重新运行npm run build进行打包就可在控制台看到各种loader的处理时间。如下图所示：

![为优化前打包时间的量化分析](/Users/chengliang/Projects/Frontend/2020-08-07/img/img-2.png)

可以看到在loader部分总共有四个地方需要优化。

第一个是babel-loader，出上图可以看出babel-loader处理1071个文件耗时25.41秒。根据我的分析主要是下面这个规则导致的：

```javascript
{
  test: /\.(js|mjs)$/,
  exclude: /@babel(?:\/|\\{1,2})runtime/,
  loader: require.resolve("babel-loader"),
  options: {
    babelrc: false,
    configFile: false,
    compact: false,
    presets: [
      [
        require.resolve("babel-preset-react-app/dependencies"),
        { helpers: true }
      ]
    ],
    cacheDirectory: true,
    cacheCompression: isEnvProduction,
    sourceMaps: false
  }
},
```

该规则主要作用是使用babel-loader处理我们项目中所用到的第三方库。

第二个是mini-css-extract-plugin, and css-loader, and postcss-loader, and resolve-url-loader, and sass-loader，其实我们看一下输出就知道这个是对项目中.sass文件进行处理的规则，该规则组合了一系列loader,最终将.sass文件转化为了.css文件。这条规则总共处理了139个文件耗时24.18秒。

第三个是babel-loader, and eslint-loader，这条规则主要作用是将我们的业务代码先通过eslint进行检查然后通过babel-loader进行代码转换。该规则处理了246个文件，耗时23.61秒。

第四个其实和第二个讲的是同一个事情，只是统计了一下不经过mini-css-extract-plugin处理所消耗的时间。

## 3. 使用thread-loader优化打包速度

通过上面讲述我们已经确定了项目打包之所以变慢是由于loader处理时间过长导致的，确切的说是由于loader对.tsx和.sass文件处理时间过长导致的。我们知道webpack打包的过程是单进程单线程的，如何我们能够将对不同文件处理的loaders放单不同的进程中，那么我们就可以并行的处理不同的文件从而加快webpack的打包速度。所以我们在这里引入thread-loader，并将对.tsx以及.sass文件的处理放在不同的进程中进行并行处理从而加快打包速度。thread-loader的使用方式很简单，大家可以参考[webpack的thread-loader的文档](https://www.webpackjs.com/loaders/thread-loader/ )进行配置即可。

虽然thred-loader的配置很简单，但是使用起来还是有几个小坑需要注意。

首先，由于thread-loader不能进行写文件因此，像style-loader、MiniCssExtractPlugin.loader这些最终会写文件的loader是不能放在thread-loader之后的，因为这样就相当于在thread-loader开启的进程中进行了写文件操作。所以我们要改写成：`use:[style-loader, thread-loader, css-loader, sass-loader]`这样的形式。

其次，在thread-loader之后的loader的options对象的属性不能是函数。我猜是因为这些选项对象会被转换为字符串后发送给loader所在的进程，但是函数是无法被转化为json的，因此当loader读取配置的时候会读不到options中的值从而造成错误。如下所示：

```javascript
{
  loader: require.resolve("postcss-loader"),
  options: {
    ident: "postcss",
    plugins: () => [
      require("postcss-flexbugs-fixes"),
      require("postcss-preset-env")({
        autoprefixer: {
          flexbox: "no-2009"
        },
        stage: 3
      }),
      postcssNormalize()
    ],
    sourceMap: isEnvProduction && shouldUseSourceMap
  }
}
```

但我们这样配置postcss-loader时由于plugins是函数，最终在thread-loader中无法读取到plugins的配置。解决方案就是使用postcss.config.js配置文件来设置postcss的选项。对于其他loader我们也要注意选项对象中的属性是函数的问题。

第三，在使用thread-loader时，css-loader选项对象中设置modules属性时会报`type error [err_invalid_arg_type]: the "from" argument must be of type string. received type undefined`，由于之前使用的css-loader版本为2.1.1所以我想可能是版本太老的缘故，将css-loader升级为4.2版本但是问题依旧。最终发现只有当css-loader版本为3.6.0的版本时可以正常运行。

在完成这些配置之后项目的打包速度如下所示：

![使用thread-loader优化后的打包时间](/Users/chengliang/Projects/Frontend/2020-08-07/img/img-3.png)

可以看到使用thread-loader后打包时间从原来的41秒缩短到了26秒。

